import{$ as e,n as t,o as n,p as a,q as o,r,h as s,k as i,t as l,v as u,x as c,y as d,z as p,A as f,B as v,C as h}from"../runtime.mjs";import{b as y,u as g,g as m,i as x,d as _,a as w,c as b,e as C,s as R,r as P,f as k,w as A,h as N,m as D,j as S,k as H,l as E,p as j,o as T,n as U,t as $,q as O,v as L,x as W,y as M,z as F,A as q,B as I,C as z,D as G,E as V,F as B,G as J,H as K,I as Y,J as Q,K as X}from"../routes/renderer.mjs";const Z="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof global?global:{},ee="__unctx__",te=Z[ee]||(Z[ee]=function(e={}){const t={};return{get:(n,a={})=>(t[n]||(t[n]=function(e={}){let t,n=!1;const checkConflict=e=>{if(t&&t!==e)throw new Error("Context conflict")};let a;if(e.asyncContext){const t=e.AsyncLocalStorage||globalThis.AsyncLocalStorage;t?a=new t:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const _getCurrentInstance=()=>{if(a&&void 0===t){const e=a.getStore();if(void 0!==e)return e}return t};return{use:()=>{const e=_getCurrentInstance();if(void 0===e)throw new Error("Context is not available");return e},tryUse:()=>_getCurrentInstance(),set:(e,a)=>{a||checkConflict(e),t=e,n=!0},unset:()=>{t=void 0,n=!1},call:(e,o)=>{checkConflict(e),t=e;try{return a?a.run(e,o):o()}finally{n||(t=void 0)}},async callAsync(e,o){t=e;const onRestore=()=>{t=e},onLeave=()=>t===e?onRestore:void 0;ae.add(onLeave);try{const r=a?a.run(e,o):o();return n||(t=void 0),await r}finally{ae.delete(onLeave)}}}}({...e,...a})),t[n],t[n])}}()),getContext=(e,t={})=>te.get(e,t),ne="__unctx_async_handlers__",ae=Z[ne]||(Z[ne]=new Set);globalThis.$fetch||(globalThis.$fetch=e.create({baseURL:y()}));const oe={componentName:"NuxtLink"},re={value:null,errorValue:null,deep:!0},se={},ie="nuxt-app";function getNuxtAppCtx(e=ie){return getContext(e,{asyncContext:!1})}const le="__nuxt_plugin";function registerPluginHooks(e,t){t.hooks&&e.hooks.addHooks(t.hooks)}function defineNuxtPlugin(e){if("function"==typeof e)return e;const t=e._name||e.name;return delete e.name,Object.assign(e.setup||(()=>{}),e,{[le]:!0,_name:t})}function callWithNuxt(e,t,n){const fn=()=>t(),a=getNuxtAppCtx(e._name);return e.vueApp.runWithContext((()=>a.callAsync(e,fn)))}function useNuxtApp(e){const t=function(e){var t;let n;return H()&&(n=null==(t=E())?void 0:t.appContext.app.$nuxt),n=n||getNuxtAppCtx(e).tryUse(),n||null}(e);if(!t)throw new Error("[nuxt] instance unavailable");return t}function useRuntimeConfig(e){return useNuxtApp().$config}function defineGetter(e,t,n){Object.defineProperty(e,t,{get:()=>n})}const ue=Symbol("route"),useRouter=()=>{var e;return null==(e=useNuxtApp())?void 0:e.$router};function defineNuxtRouteMiddleware(e){return e}const navigateTo=(e,o)=>{e||(e="/");const s="string"==typeof e?e:"path"in e?resolveRouteObject(e):useRouter().resolve(e).href,i=t(s,{acceptRelative:!0}),l=(null==o?void 0:o.external)||i;if(l){if(!(null==o?void 0:o.external))throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");const{protocol:e}=new URL(s,"http://localhost");if(e&&n(e))throw new Error(`Cannot navigate to a URL with '${e}' protocol.`)}const u=(()=>{try{if(useNuxtApp()._processingMiddleware)return!0}catch{return!1}return!1})(),c=useRouter(),d=useNuxtApp();if(d.ssrContext){const t="string"==typeof e||l?s:c.resolve(e).fullPath||"/",n=l?s:a(useRuntimeConfig().app.baseURL,t),redirect=async function(e){await d.callHook("app:redirected");const t=n.replace(/"/g,"%22"),a=function(e,t=!1){const n=new URL(e,"http://localhost");if(!t)return n.pathname+n.search+n.hash;if(e.startsWith("//"))return n.toString().replace(n.protocol,"");return n.toString()}(n,i);return d.ssrContext._renderResponse={statusCode:r((null==o?void 0:o.redirectCode)||302,302),body:`<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${t}"></head></html>`,headers:{location:a}},e};return!l&&u?(c.afterEach((e=>e.fullPath===t?redirect(!1):void 0)),e):redirect(!u&&void 0)}return l?(d._scope.stop(),(null==o?void 0:o.replace)?(void 0).replace(s):(void 0).href=s,u?!!d.isHydrating&&new Promise((()=>{})):Promise.resolve()):(null==o?void 0:o.replace)?c.replace(e):c.push(e)};function resolveRouteObject(e){return o(e.path||"",e.query||{})+(e.hash||"")}const ce="__nuxt_error",useError=()=>$(useNuxtApp().payload,"error"),showError=e=>{const t=createError(e);try{useNuxtApp();const e=useError();0,e.value=e.value||t}catch{throw t}return t},createError=e=>{const t=i(e);return Object.defineProperty(t,ce,{value:!0,configurable:!1,writable:!1}),t};function resolveUnrefHeadInput(e,t=""){if(e instanceof Promise)return e;const n="function"==typeof(a=e)?a():g(a);var a;return e&&n?Array.isArray(n)?n.map((e=>resolveUnrefHeadInput(e,t))):"object"==typeof n?Object.fromEntries(Object.entries(n).map((([e,t])=>"titleTemplate"===e||e.startsWith("on")?[e,g(t)]:[e,resolveUnrefHeadInput(t,e)]))):n:n}const de="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},pe="__unhead_injection_handler__";function injectHead(){if(pe in de)return de[pe]();const e=x("usehead");return e||m()}const fe=defineNuxtPlugin({name:"nuxt:head",enforce:"pre",setup(e){const t=e.ssrContext.head;var n;n=()=>useNuxtApp().vueApp._context.provides.usehead,de[pe]=n,e.vueApp.use(t)}});const ve="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof global?global:{},he="__unctx__";ve[he]||(ve[he]=function(e={}){const t={};return{get:(n,a={})=>(t[n]||(t[n]=function(e={}){let t,n=!1;const checkConflict=e=>{if(t&&t!==e)throw new Error("Context conflict")};let a;if(e.asyncContext){const t=e.AsyncLocalStorage||globalThis.AsyncLocalStorage;t?a=new t:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const _getCurrentInstance=()=>{if(a&&void 0===t){const e=a.getStore();if(void 0!==e)return e}return t};return{use:()=>{const e=_getCurrentInstance();if(void 0===e)throw new Error("Context is not available");return e},tryUse:()=>_getCurrentInstance(),set:(e,a)=>{a||checkConflict(e),t=e,n=!0},unset:()=>{t=void 0,n=!1},call:(e,o)=>{checkConflict(e),t=e;try{return a?a.run(e,o):o()}finally{n||(t=void 0)}},async callAsync(e,o){t=e;const onRestore=()=>{t=e},onLeave=()=>t===e?onRestore:void 0;ge.add(onLeave);try{const r=a?a.run(e,o):o();return n||(t=void 0),await r}finally{ge.delete(onLeave)}}}}({...e,...a})),t[n],t[n])}}());const ye="__unctx_async_handlers__",ge=ve[ye]||(ve[ye]=new Set),me=[defineNuxtRouteMiddleware((async e=>{}))];function getRouteFromPath(e){"object"==typeof e&&(e=f({pathname:e.path||"",search:v(e.query||{}),hash:e.hash||""}));const t=new URL(e.toString(),"http://localhost");return{path:t.pathname,fullPath:e,query:h(t.search),hash:t.hash,params:{},name:void 0,matched:[],redirectedFrom:void 0,meta:{},href:e}}const xe={NuxtError:e=>{return!!(t=e)&&"object"==typeof t&&ce in t&&e.toJSON();var t},EmptyShallowRef:e=>G(e)&&V(e)&&!e.value&&("bigint"==typeof e.value?"0n":JSON.stringify(e.value)||"_"),EmptyRef:e=>G(e)&&!e.value&&("bigint"==typeof e.value?"0n":JSON.stringify(e.value)||"_"),ShallowRef:e=>G(e)&&V(e)&&e.value,ShallowReactive:e=>B(e)&&V(e)&&J(e),Ref:e=>G(e)&&e.value,Reactive:e=>B(e)&&J(e)},_e=[fe,defineNuxtPlugin({name:"nuxt:router",enforce:"pre",setup(e){const t=e.ssrContext.url,n=[],a={"navigate:before":[],"resolve:before":[],"navigate:after":[],error:[]},registerHook=(e,t)=>(a[e].push(t),()=>a[e].splice(a[e].indexOf(t),1));useRuntimeConfig().app.baseURL;const o=P(getRouteFromPath(t));async function handleNavigation(e,t){try{const t=getRouteFromPath(e);for(const e of a["navigate:before"]){const n=await e(t,o);if(!1===n||n instanceof Error)return;if("string"==typeof n&&n.length)return handleNavigation(n,!0)}for(const e of a["resolve:before"])await e(t,o);Object.assign(o,t);for(const e of a["navigate:after"])await e(t,o)}catch(e){for(const t of a.error)await t(e)}}const r={currentRoute:O((()=>o)),isReady:()=>Promise.resolve(),options:{},install:()=>Promise.resolve(),push:e=>handleNavigation(e),replace:e=>handleNavigation(e),back:()=>(void 0).history.go(-1),go:e=>(void 0).history.go(e),forward:()=>(void 0).history.go(1),beforeResolve:e=>registerHook("resolve:before",e),beforeEach:e=>registerHook("navigate:before",e),afterEach:e=>registerHook("navigate:after",e),onError:e=>registerHook("error",e),resolve:getRouteFromPath,addRoute:(e,t)=>{n.push(t)},getRoutes:()=>n,hasRoute:e=>n.some((t=>t.name===e)),removeRoute:e=>{const t=n.findIndex((t=>t.name===e));-1!==t&&n.splice(t,1)}};e.vueApp.component("RouterLink",_({functional:!0,props:{to:{type:String,required:!0},custom:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:String},setup:(e,{slots:t})=>{const navigate=()=>handleNavigation(e.to,e.replace);return()=>{var n;const a=r.resolve(e.to);return e.custom?null==(n=t.default)?void 0:n.call(t,{href:e.to,navigate:navigate,route:a}):L("a",{href:e.to,onClick:e=>(e.preventDefault(),navigate())},t)}}})),e._route=o,e._middleware=e._middleware||{global:[],named:{}};const s=e.payload.state._layout;return e.hooks.hookOnce("app:created",(async()=>{r.beforeEach((async(n,a)=>{var o;if(n.meta=P(n.meta||{}),e.isHydrating&&s&&!W(n.meta.layout)&&(n.meta.layout=s),e._processingMiddleware=!0,!(null==(o=e.ssrContext)?void 0:o.islandContext)){const o=new Set([...me,...e._middleware.global]);{const t=await e.runWithContext((()=>async function(e){{const t=c(d({routes:useRuntimeConfig().nitro.routeRules}));return p({},...t.matchAll(e).reverse())}}(n.path)));if(t.appMiddleware)for(const n in t.appMiddleware){const a=e._middleware.named[n];if(!a)return;t.appMiddleware[n]?o.add(a):o.delete(a)}}for(const r of o){const o=await e.runWithContext((()=>r(n,a)));if(!1===o||o instanceof Error){const n=o||i({statusCode:404,statusMessage:`Page Not Found: ${t}`,data:{path:t}});return delete e._processingMiddleware,e.runWithContext((()=>showError(n)))}if(!0!==o&&(o||!1===o))return o}}})),r.afterEach((()=>{delete e._processingMiddleware})),await r.replace(t),l(o.fullPath,t)||await e.runWithContext((()=>navigateTo(o.fullPath)))})),{provide:{route:o,router:r}}}}),defineNuxtPlugin({name:"nuxt:revive-payload:server",setup(){for(const n in xe)e=n,t=xe[n],useNuxtApp().ssrContext._payloadReducers[e]=t;var e,t}}),defineNuxtPlugin({name:"nuxt:global-components"})];function useRequestFetch(){var e;return(null==(e=function(e=useNuxtApp()){var t;return null==(t=e.ssrContext)?void 0:t.event}())?void 0:e.$fetch)||globalThis.$fetch}const isDefer=e=>"defer"===e||!1===e;function useAsyncData(...e){var t;const n="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(n);let[a,o,r={}]=e;if("string"!=typeof a)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof o)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const s=useNuxtApp(),i=o;r.server=r.server??!0,r.default=r.default??(()=>re.value),r.getCachedData=r.getCachedData??(()=>s.isHydrating?s.payload.data[a]:s.static.data[a]),r.lazy=r.lazy??!1,r.immediate=r.immediate??!0,r.deep=r.deep??re.deep,r.dedupe=r.dedupe??"cancel";const hasCachedData=()=>null!=r.getCachedData(a,s);if(!s._asyncData[a]||!r.immediate){(t=s.payload._errors)[a]??(t[a]=re.errorValue);const e=r.deep?K:Y;s._asyncData[a]={data:e(r.getCachedData(a,s)??r.default()),pending:K(!hasCachedData()),error:$(s.payload._errors,a),status:K("idle"),_default:r.default}}const l={...s._asyncData[a]};delete l._default,l.refresh=l.execute=(e={})=>{if(s._asyncDataPromises[a]){if(isDefer(e.dedupe??r.dedupe))return s._asyncDataPromises[a];s._asyncDataPromises[a].cancelled=!0}if((e._initial||s.isHydrating&&!1!==e._initial)&&hasCachedData())return Promise.resolve(r.getCachedData(a,s));l.pending.value=!0,l.status.value="pending";const t=new Promise(((e,t)=>{try{e(i(s))}catch(e){t(e)}})).then((async e=>{if(t.cancelled)return s._asyncDataPromises[a];let n=e;r.transform&&(n=await r.transform(e)),r.pick&&(n=function(e,t){const n={};for(const a of t)n[a]=e[a];return n}(n,r.pick)),s.payload.data[a]=n,l.data.value=n,l.error.value=re.errorValue,l.status.value="success"})).catch((e=>{if(t.cancelled)return s._asyncDataPromises[a];l.error.value=createError(e),l.data.value=g(r.default()),l.status.value="error"})).finally((()=>{t.cancelled||(l.pending.value=!1,delete s._asyncDataPromises[a])}));return s._asyncDataPromises[a]=t,s._asyncDataPromises[a]},l.clear=()=>function(e,t){t in e.payload.data&&(e.payload.data[t]=void 0);t in e.payload._errors&&(e.payload._errors[t]=re.errorValue);e._asyncData[t]&&(e._asyncData[t].data.value=void 0,e._asyncData[t].error.value=re.errorValue,e._asyncData[t].pending.value=!1,e._asyncData[t].status.value="idle");t in e._asyncDataPromises&&(e._asyncDataPromises[t]&&(e._asyncDataPromises[t].cancelled=!0),e._asyncDataPromises[t]=void 0)}(s,a);if(!1!==r.server&&s.payload.serverRendered&&r.immediate){const e=l.refresh({_initial:!0});E()?Q((()=>e)):s.hook("app:created",(async()=>{await e}))}const u=Promise.resolve(s._asyncDataPromises[a]).then((()=>l));return Object.assign(u,l),u}function generateOptionSegments(e){var t;const n=[(null==(t=M(e.method))?void 0:t.toUpperCase())||"GET",M(e.baseURL)];for(const t of[e.params||e.query]){const e=M(t);if(!e)continue;const a={};for(const[t,n]of Object.entries(e))a[M(t)]=M(n);n.push(a)}return n}const we=_({__name:"app",__ssrInlineRender:!0,async setup(e){let t,n;const{data:a}=([t,n]=A((()=>function(e,t){const[n={},a]=[{},t],o=O((()=>M(e))),r=n.key||u([a,"string"==typeof o.value?o.value:"",...generateOptionSegments(n)]);if(!r||"string"!=typeof r)throw new TypeError("[nuxt] [useFetch] key must be a string: "+r);const s=r===a?"$f"+r:r;if(!n.baseURL&&"string"==typeof o.value&&"/"===o.value[0]&&"/"===o.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:i,lazy:l,default:c,transform:d,pick:p,watch:f,immediate:v,getCachedData:h,deep:y,dedupe:g,...m}=n,x=P({...se,...m,cache:"boolean"==typeof n.cache?void 0:n.cache});let _;return useAsyncData(s,(()=>{var e;null==(e=null==_?void 0:_.abort)||e.call(_),_="undefined"!=typeof AbortController?new AbortController:{};const t=M(n.timeout);let a;t&&(a=setTimeout((()=>_.abort()),t),_.signal.onabort=()=>clearTimeout(a));let r=n.$fetch||globalThis.$fetch;return n.$fetch||"string"==typeof o.value&&"/"===o.value[0]&&(!M(n.baseURL)||"/"===M(n.baseURL)[0])&&(r=useRequestFetch()),r(o.value,{signal:_.signal,...x}).finally((()=>{clearTimeout(a)}))}),{server:i,lazy:l,default:c,transform:d,pick:p,immediate:v,getCachedData:h,deep:y,dedupe:g,watch:!1===f?[]:[x,o,...f||[]]})}("/api/teste","$siNM9WAguS"))),t=await t,n(),t);return(e,t,n,o)=>{t(`<div${N(D({class:"flex flex-col h-96 justify-center items-center"},o))}><div class="text-4xl font-semibold">Hi with <span class="underline text-red-600">TailwindCSS</span></div><pre class="mt-32"><code> ${S(g(a)||"vazio")}</code></pre></div>`)}}}),be=we.setup;we.setup=(e,t)=>{const n=w();return(n.modules||(n.modules=new Set)).add("app.vue"),be?be(e,t):void 0};const Ce={__name:"nuxt-error-page",__ssrInlineRender:!0,props:{error:Object},setup(e){const t=e.error;t.stack&&t.stack.split("\n").splice(1).map((e=>({text:e.replace("webpack:/","").replace(".vue",".js").trim(),internal:e.includes("node_modules")&&!e.includes(".cache")||e.includes("internal")||e.includes("new Promise")}))).map((e=>`<span class="stack${e.internal?" internal":""}">${e.text}</span>`)).join("\n");const n=Number(t.statusCode||500),a=404===n,o=t.statusMessage??(a?"Page Not Found":"Internal Server Error"),r=t.message||t.toString(),s=X((()=>import("./error-404-CcUH1itg.mjs").then((e=>e.default||e)))),i=X((()=>import("./error-500-CTl04f3M.mjs").then((e=>e.default||e)))),l=a?s:i;return(e,t,a,s)=>{t(F(g(l),D({statusCode:g(n),statusMessage:g(o),description:g(r),stack:g(undefined)},s),null,a))}}},Re=Ce.setup;Ce.setup=(e,t)=>{const n=w();return(n.modules||(n.modules=new Set)).add("node_modules/nuxt/dist/app/components/nuxt-error-page.vue"),Re?Re(e,t):void 0};const Pe={__name:"nuxt-root",__ssrInlineRender:!0,setup(e){const IslandRenderer=()=>null,t=useNuxtApp();t.deferHydration(),t.ssrContext.url;const n=!1;j(ue,H()?x(ue,useNuxtApp()._route):useNuxtApp()._route),t.hooks.callHookWith((e=>e.map((e=>e()))),"vue:setup");const a=useError(),o=a.value&&!t.ssrContext.error;T(((e,n,a)=>{t.hooks.callHook("vue:error",e,n,a).catch((e=>console.error("[nuxt] Error in `vue:error` hook",e)));{const n=t.runWithContext((()=>showError(e)));return Q((()=>n)),!1}}));const r=t.ssrContext.islandContext;return(e,t,s,i)=>{U(t,{default:()=>{g(o)?t("<div></div>"):g(a)?t(F(g(Ce),{error:g(a)},null,s)):g(r)?t(F(g(IslandRenderer),{context:g(r)},null,s)):g(n)?q(t,I(z(g(n)),null,null),s):t(F(g(we),null,null,s))},_:1})}}},ke=Pe.setup;let Ae;Pe.setup=(e,t)=>{const n=w();return(n.modules||(n.modules=new Set)).add("node_modules/nuxt/dist/app/components/nuxt-root.vue"),ke?ke(e,t):void 0},Ae=async function(e){const t=b(Pe),n=function(e){let t=0;const n={_name:ie,_scope:C(),provide:void 0,globalName:"nuxt",versions:{get nuxt(){return"3.12.4"},get vue(){return n.vueApp.version}},payload:R({data:R({}),state:P({}),once:new Set,_errors:R({})}),static:{data:{}},runWithContext:e=>n._scope.active&&!k()?n._scope.run((()=>callWithNuxt(n,e))):callWithNuxt(n,e),isHydrating:!1,deferHydration(){if(!n.isHydrating)return()=>{};t++;let e=!1;return()=>{if(!e)return e=!0,t--,0===t?(n.isHydrating=!1,n.callHook("app:suspense:resolve")):void 0}},_asyncDataPromises:{},_asyncData:R({}),_payloadRevivers:{},...e};n.payload.serverRendered=!0,n.hooks=s(),n.hook=n.hooks.hook;{const contextCaller=async function(e,t){for(const a of e)await n.runWithContext((()=>a(...t)))};n.hooks.callHook=(e,...t)=>n.hooks.callHookWith(contextCaller,e,...t)}n.callHook=n.hooks.callHook,n.provide=(e,t)=>{const a="$"+e;defineGetter(n,a,t),defineGetter(n.vueApp.config.globalProperties,a,t)},defineGetter(n.vueApp,"$nuxt",n),defineGetter(n.vueApp.config.globalProperties,"$nuxt",n),n.ssrContext&&(n.ssrContext.nuxt=n,n.ssrContext._payloadReducers={},n.payload.path=n.ssrContext.url),n.ssrContext=n.ssrContext||{},n.ssrContext.payload&&Object.assign(n.payload,n.ssrContext.payload),n.ssrContext.payload=n.payload,n.ssrContext.config={public:e.ssrContext.runtimeConfig.public,app:e.ssrContext.runtimeConfig.app};const a=e.ssrContext.runtimeConfig;return n.provide("config",a),n}({vueApp:t,ssrContext:e});try{await async function(e,t){var n,a,o,r;const s=[],i=[],l=[],u=[];let c=0;async function executePlugin(n){var a;const o=(null==(a=n.dependsOn)?void 0:a.filter((e=>t.some((t=>t._name===e))&&!s.includes(e))))??[];if(o.length>0)i.push([new Set(o),n]);else{const t=async function(e,t){if("function"==typeof t){const{provide:n}=await e.runWithContext((()=>t(e)))||{};if(n&&"object"==typeof n)for(const t in n)e.provide(t,n[t])}}(e,n).then((async()=>{n._name&&(s.push(n._name),await Promise.all(i.map((async([e,t])=>{e.has(n._name)&&(e.delete(n._name),0===e.size&&(c++,await executePlugin(t)))}))))}));n.parallel?l.push(t.catch((e=>u.push(e)))):await t}}for(const o of t)(null==(n=e.ssrContext)?void 0:n.islandContext)&&!1===(null==(a=o.env)?void 0:a.islands)||registerPluginHooks(e,o);for(const n of t)(null==(o=e.ssrContext)?void 0:o.islandContext)&&!1===(null==(r=n.env)?void 0:r.islands)||await executePlugin(n);if(await Promise.all(l),c)for(let e=0;e<c;e++)await Promise.all(l);if(u.length)throw u[0]}(n,_e),await n.hooks.callHook("app:created",t)}catch(e){await n.hooks.callHook("app:error",e),n.payload.error=n.payload.error||createError(e)}if(null==e?void 0:e._renderResponse)throw new Error("skipping render");return t};const entry$1=e=>Ae(e);export{navigateTo as a,useRuntimeConfig as b,resolveUnrefHeadInput as c,entry$1 as default,injectHead as i,oe as n,resolveRouteObject as r,useRouter as u};
//# sourceMappingURL=server.mjs.map
