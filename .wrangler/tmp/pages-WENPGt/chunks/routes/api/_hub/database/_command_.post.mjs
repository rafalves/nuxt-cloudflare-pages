import{e as a,g as r,l as e}from"../../../../runtime.mjs";import{z as t,h as s}from"../../../../_/index.mjs";import{r as m}from"../../../../_/auth.mjs";import{r as n}from"../../../../_/features.mjs";const i=t.object({query:t.string().min(1).max(1e6).trim(),params:t.any().array().default([])}),o=a((async a=>{await m(a),n("database");const{command:o}=await r(a,t.object({command:t.enum(["first","all","raw","run","dump","exec","batch"])}).parse),p=s();if("exec"===o){const{query:r}=await e(a,i.pick({query:!0}).parse);return p.exec(r)}if("dump"===o)return p.dump();if("first"===o){const{query:r,params:s,colName:m}=await e(a,t.intersection(i,t.object({colName:t.string().optional()})).parse);return m?p.prepare(r).bind(...s).first(m):p.prepare(r).bind(...s).first()}if("batch"===o){const r=await e(a,t.array(i).parse);return p.batch(r.map((a=>p.prepare(a.query).bind(...a.params))))}if("raw"===o){const{query:r,params:s,columnNames:m}=await e(a,t.intersection(i,t.object({columnNames:t.boolean().default(!1)})).parse);return p.prepare(r).bind(...s).raw({columnNames:m})}const{query:c,params:u}=await e(a,i.parse);return p.prepare(c).bind(...u)[o]()}));export{o as default};
//# sourceMappingURL=_command_.post.mjs.map
