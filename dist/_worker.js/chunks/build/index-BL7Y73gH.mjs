import{C as e}from"../runtime.mjs";import{f as a,c as t,d as s,e as r}from"./server.mjs";import{d as n,f as o,L as l,M as i,G as c,N as u,u as d,c as f,O as p,r as y,b as m,s as v,v as h,o as g,H as _}from"../routes/renderer.mjs";function useRequestFetch(){var e;return(null==(e=function(e=t()){var a;return null==(a=e.ssrContext)?void 0:a.event}())?void 0:e.$fetch)||globalThis.$fetch}const isDefer=e=>"defer"===e||!1===e;function useAsyncData(...e){var a,n,o,l,i,c,u,f,p;const y="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(y);let[D,b,w={}]=e;if("string"!=typeof D)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof b)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const P=t(),C=b;w.server=null==(a=w.server)||a,w.default=null!=(n=w.default)?n:()=>s.value,w.getCachedData=null!=(o=w.getCachedData)?o:()=>P.isHydrating?P.payload.data[D]:P.static.data[D],w.lazy=null!=(l=w.lazy)&&l,w.immediate=null==(i=w.immediate)||i,w.deep=null!=(c=w.deep)?c:s.deep,w.dedupe=null!=(u=w.dedupe)?u:"cancel";const hasCachedData=()=>null!=w.getCachedData(D,P);if(!P._asyncData[D]||!w.immediate){null!=(p=P.payload._errors)[D]||(p[D]=s.errorValue);const e=w.deep?m:v;P._asyncData[D]={data:e(null!=(f=w.getCachedData(D,P))?f:w.default()),pending:m(!hasCachedData()),error:h(P.payload._errors,D),status:m("idle"),_default:w.default}}const x={...P._asyncData[D]};delete x._default,x.refresh=x.execute=(e={})=>{var a;if(P._asyncDataPromises[D]){if(isDefer(null!=(a=e.dedupe)?a:w.dedupe))return P._asyncDataPromises[D];P._asyncDataPromises[D].cancelled=!0}if((e._initial||P.isHydrating&&!1!==e._initial)&&hasCachedData())return Promise.resolve(w.getCachedData(D,P));x.pending.value=!0,x.status.value="pending";const t=new Promise(((e,a)=>{try{e(C(P))}catch(e){a(e)}})).then((async e=>{if(t.cancelled)return P._asyncDataPromises[D];let a=e;w.transform&&(a=await w.transform(e)),w.pick&&(a=function(e,a){const t={};for(const s of a)t[s]=e[s];return t}(a,w.pick)),P.payload.data[D]=a,x.data.value=a,x.error.value=s.errorValue,x.status.value="success"})).catch((e=>{if(t.cancelled)return P._asyncDataPromises[D];x.error.value=r(e),x.data.value=d(w.default()),x.status.value="error"})).finally((()=>{t.cancelled||(x.pending.value=!1,delete P._asyncDataPromises[D])}));return P._asyncDataPromises[D]=t,P._asyncDataPromises[D]},x.clear=()=>function(e,a){a in e.payload.data&&(e.payload.data[a]=void 0);a in e.payload._errors&&(e.payload._errors[a]=s.errorValue);e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=s.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle");a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}(P,D);if(!1!==w.server&&P.payload.serverRendered&&w.immediate){const e=x.refresh({_initial:!0});g()?_((()=>e)):P.hook("app:created",(async()=>{await e}))}const k=Promise.resolve(P._asyncDataPromises[D]).then((()=>x));return Object.assign(k,x),k}function generateOptionSegments(e){var a;const t=[(null==(a=p(e.method))?void 0:a.toUpperCase())||"GET",p(e.baseURL)];for(const a of[e.params||e.query]){const e=p(a);if(!e)continue;const s={};for(const[a,t]of Object.entries(e))s[p(a)]=p(t);t.push(s)}return t}const D=n({__name:"index",__ssrInlineRender:!0,async setup(t){let s,r;const{data:n}=([s,r]=l((()=>function(t,s){const[r={},n]=[{},s],o=f((()=>p(t))),l=r.key||e([n,"string"==typeof o.value?o.value:"",...generateOptionSegments(r)]);if(!l||"string"!=typeof l)throw new TypeError("[nuxt] [useFetch] key must be a string: "+l);const i=l===n?"$f"+l:l;if(!r.baseURL&&"string"==typeof o.value&&"/"===o.value[0]&&"/"===o.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:c,lazy:u,default:d,transform:m,pick:v,watch:h,immediate:g,getCachedData:_,deep:D,dedupe:b,...w}=r,P=y({...a,...w,cache:"boolean"==typeof r.cache?void 0:r.cache});let C;return useAsyncData(i,(()=>{var e;null==(e=null==C?void 0:C.abort)||e.call(C),C="undefined"!=typeof AbortController?new AbortController:{};const a=p(r.timeout);let t;a&&(t=setTimeout((()=>C.abort()),a),C.signal.onabort=()=>clearTimeout(t));let s=r.$fetch||globalThis.$fetch;return r.$fetch||"string"==typeof o.value&&"/"===o.value[0]&&(!p(r.baseURL)||"/"===p(r.baseURL)[0])&&(s=useRequestFetch()),s(o.value,{signal:C.signal,...P}).finally((()=>{clearTimeout(t)}))}),{server:c,lazy:u,default:d,transform:m,pick:v,immediate:g,getCachedData:_,deep:D,dedupe:b,watch:!1===h?[]:[P,o,...h||[]]})}("/api/teste","$pqtWcjQkdb"))),s=await s,r(),s);return(e,a,t,s)=>{a(`<div${i(c({class:"flex flex-col items-center"},s))}><pre><code> ${u(d(n)||"vazio")}</code></pre></div>`)}}}),b=D.setup;D.setup=(e,a)=>{const t=o();return(t.modules||(t.modules=new Set)).add("pages/index.vue"),b?b(e,a):void 0};export{D as default};
//# sourceMappingURL=index-BL7Y73gH.mjs.map
